<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Developer Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="setting_things_up.html"><strong aria-hidden="true">1.</strong> Setting Things Up</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Setting up the compiler</div></li><li class="chapter-item expanded "><a href="setting_up_LLD_linker.html"><strong aria-hidden="true">1.2.</strong> Setting up the linker</a></li><li class="chapter-item expanded "><a href="setting_up_qemu.html"><strong aria-hidden="true">1.3.</strong> Setting up the Riscv Virtual environment</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Setting up the Build automation tool</div></li></ol></li><li class="chapter-item expanded "><a href="definitions_and_theories.html"><strong aria-hidden="true">2.</strong> Definitions and Theories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="theory_on_the_linker.html"><strong aria-hidden="true">2.1.</strong> The linker</a></li><li class="chapter-item expanded "><a href="theory_on_Qemu.html"><strong aria-hidden="true">2.2.</strong> Qemu</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="setting-things-up"><a class="header" href="#setting-things-up">Setting Things Up</a></h2>
<p>Under this chapter, we intend to answer the following 3 questions :</p>
<ol>
<li>What are we setting up?</li>
<li>Why are we setting up those things?</li>
<li>How are we seting up those things?</li>
</ol>
<h3 id="what-are-we-setting-up"><a class="header" href="#what-are-we-setting-up">What are we setting up?</a></h3>
<p>We are setting up a <strong>development toolchain</strong>, <strong>RISCV virtual environment</strong> and a <strong>no-std Rust file</strong>.</p>
<h4 id="the-development-toolchain"><a class="header" href="#the-development-toolchain">The development Toolchain</a></h4>
<p>A toolchain is a group of software tools that typically get used together...a chain of tools...
In OS Development, the name toolchain usually refers to the combination of the compiler, linker, debugger and a bunch of programs that help in inspecting files. This toolchain gets used to convert source code into a format that can run on an execution <em>environment</em>.</p>
<p>An execution environment is a place where a software program can run. It provides the necessary resources, like the operating system and libraries, that the program needs to function. Examples of execution enviroments include: Bare metal, Browsers, Virtual Machines, Operating systems and Containers.</p>
<p>The toolchain in our case will consist of the following tools :</p>
<ol>
<li>The Rust Nightly Compiler with a riscv64gc-unknown-none-elf backend</li>
<li>linker : Rust-lld</li>
<li>Binutils </li>
<li>Make</li>
</ol>
<p>To our luck, we do not have to install all these elements seperately. There exists compact toolchains :</p>
<ol>
<li>LLVM Riscv toolchain</li>
<li>The GNU Riscv Toolchain</li>
</ol>
<h4 id="why-we-need-the-toolchain"><a class="header" href="#why-we-need-the-toolchain">Why we need the toolchain</a></h4>
<p>We will have two kinds of source code files in our project : Rust source files and RISCV-Assembly files. Both of these types of files need to be turned into object files. Afterwards, those object files need to get linked together into a single executable file.</p>
<p>We can go about this process of creating a single executable file in two ways:
1. Method 1 
We can compile the Rust files seperately from the Assembly files. Afterwords we can combine the resultant object files using a linker to form a single executable.
2. Method 2
We can embed the assembly code into the Rust source code. That way, we only need one compilation, we will only need to compile the asm_embedded Rust files. This method seems more of plug and play. The disadvantage is that we will always have to re-compile every file each time we change anything in any source file. But this is not really a problem. Modern compilers are Fast. This is a more user friendly method. Trading off negligible compile time over a user-friendly build and configuration process is by far a very good choice.</p>
<pre><code>    Moreover, the rust compiler comes with its own inbuilt LLVM linker, rust-lld. That means that once we hit compile, we get the executable file output. One click, and all the build process runs inbuilt; from compiling rust files, to compiling assembly files, to creating a riscv-compliant executable file
</code></pre>
<h4 id="the-rust-llvm-compiler-and-targets"><a class="header" href="#the-rust-llvm-compiler-and-targets">The Rust LLVM compiler and Targets</a></h4>
<h4 id="the-linker"><a class="header" href="#the-linker">The Linker</a></h4>
<p><em><strong>references</strong></em></p>
<ul>
<li><a href="https://lld.llvm.org/">The LLD official Page</a></li>
<li><a href="https://nnethercote.github.io/perf-book/compile-times.html">Linking in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-linker"><a class="header" href="#setting-up-the-linker">Setting up the linker</a></h1>
<p>As earlier mentioned, the Rust compiler comes with an inbuilt linker. 
Each target comes with its own configured linker</p>
<p>So by default we do not need a linker script. But as for our case, we are going to do define the memory addresses various sections of the elf file will point to. We are going to manipulate virtual memory addresses in our assembly code. So instead of letting the linker execute its default memory assignation, we define it ourselves.</p>
<p>We would not wish to work with a blackbox.</p>
<p>Here is the Linker script :</p>
<pre><code class="language-bash">
/*
  riscv is the name of the architecture that the linker understands
  for any RISC-V target (64-bit or 32-bit).

  We will further refine this by using -mabi=lp64 and -march=rv64gc
*/
OUTPUT_ARCH( &quot;riscv&quot; )

/*
We're setting our entry point to a symbol
called _start which is inside of boot.S. This
essentially stores the address of _start as the
&quot;entry point&quot;, or where CPU instructions should start
executing.

In the rest of this script, we are going to place _start
right at the beginning of 0x8000_0000 because this is where
the virtual machine and many RISC-V boards will start executing.
*/
ENTRY( _start )

/*
The MEMORY section will explain that we have &quot;ram&quot; that contains
a section that is 'w' (writeable), 'x' (executable), and 'a' (allocatable).
We use '!' to invert 'r' (read-only) and 'i' (initialized). We don't want
our memory to be read-only, and we're stating that it is NOT initialized
at the beginning.

The ORIGIN is the memory address 0x8000_0000. If we look at the virt
spec or the specification for the RISC-V HiFive Unleashed, this is the
starting memory address for our code.

Side note: There might be other boot ROMs at different addresses, but
their job is to get to this point.

Finally LENGTH = 128M tells the linker that we have 128 megabyte of RAM.
The linker will double check this to make sure everything can fit.

The HiFive Unleashed has a lot more RAM than this, but for the virtual 
machine, I went with 128M since I think that's enough RAM for now.

We can provide other pieces of memory, such as QSPI, or ROM, but we're
telling the linker script here that we have one pool of RAM.
*/
MEMORY
{
  ram   (wxa!ri) : ORIGIN = 0x80000000, LENGTH = 128M
}

/*
PHDRS is short for &quot;program headers&quot;, which we specify three here:
text - CPU instructions (executable sections)
data - Global, initialized variables
bss  - Global, uninitialized variables (all will be set to 0 by boot.S)

The command PT_LOAD tells the linker that these sections will be loaded
from the file into memory.

We can actually stuff all of these into a single program header, but by
splitting it up into three, we can actually use the other PT_* commands
such as PT_DYNAMIC, PT_INTERP, PT_NULL to tell the linker where to find
additional information.

However, for our purposes, every section will be loaded from the program
headers.
*/
PHDRS
{
  text PT_LOAD;
  data PT_LOAD;
  bss PT_LOAD;
}

/*
We are now going to organize the memory based on which
section it is in. In assembly, we can change the section
with the &quot;.section&quot; directive. However, in C++ and Rust,
CPU instructions go into text, global constants go into
rodata, global initialized variables go into data, and
global uninitialized variables go into bss.
*/
SECTIONS
{
  /*
    The first part of our RAM layout will be the text section.
	Since our CPU instructions are here, and our memory starts at
	0x8000_0000, we need our entry point to line up here.
  */
  .text : {
	  /* 
	    PROVIDE allows me to access a symbol called _text_start so
		I know where the text section starts in the operating system.
		This should not move, but it is here for convenience.
		The period '.' tells the linker to set _text_start to the
		CURRENT location ('.' = current memory location). This current
		memory location moves as we add things.
	  */

    PROVIDE(_text_start = .);
	/*
	  We are going to layout all text sections here, starting with 
	  .text.init. The asterisk in front of the parentheses means to match
	  the .text.init section of ANY object file. Otherwise, we can specify
	  which object file should contain the .text.init section, for example,
	  boot.o(.text.init) would specifically put the .text.init section of
	  our bootloader here.

	  Because we might want to change the name of our files, we'll leave it
	  with a *.

	  Inside the parentheses is the name of the section. I created my own
	  called .text.init to make 100% sure that the _start is put right at the
	  beginning. The linker will lay this out in the order it receives it:

	  .text.init first
	  all .text sections next
	  any .text.* sections last

	  .text.* means to match anything after .text. If we didn't already specify
	  .text.init, this would've matched here. The assembler and linker can place
	  things in &quot;special&quot; text sections, so we match any we might come across here.
	*/
    *(.text.init) *(.text .text.*)

	/*
	  Again, with PROVIDE, we're providing a readable symbol called _text_end, which is
	  set to the memory address AFTER .text.init, .text, and .text.*'s have been added.
	*/
    PROVIDE(_text_end = .);
	/*
	  The portion after the right brace is in an odd format. However, this is telling the
	  linker what memory portion to put it in. We labeled our RAM, ram, with the constraints
	  that it is writeable, allocatable, and executable. The linker will make sure with this
	  that we can do all of those things.

	  &gt;ram - This just tells the linker script to put this entire section (.text) into the
	         ram region of memory. To my knowledge, the '&gt;' does not mean &quot;greater than&quot;. Instead,
			 it is a symbol to let the linker know we want to put this in ram.

	  AT&gt;ram - This sets the LMA (load memory address) region to the same thing. LMA is the final
	           translation of a VMA (virtual memory address). With this linker script, we're loading
			   everything into its physical location. We'll let the kernel copy and sort out the 
			   virtual memory. That's why &gt;ram and AT&gt;ram are continually the same thing.

	  :text  - This tells the linker script to put this into the :text program header. We've only
	           defined three: text, data, and bss. In this case, we're telling the linker script
			   to go into the text section.
	*/
  } &gt;ram AT&gt;ram :text
   /*
     The global pointer allows the linker to position global variables and constants into
	 independent positions relative to the gp (global pointer) register. The globals start
	 after the text sections and are only relevant to the rodata, data, and bss sections.
   */
   PROVIDE(_global_pointer = .);
   /*
     Most compilers create a rodata (read only data) section for global constants. However,
	 we're going to place ours in the text section. We can actually put this in :data, but
	 since the .text section is read-only, we can place it there.

	 NOTE: This doesn't actually do anything, yet. The actual &quot;protection&quot; cannot be done
	 at link time. Instead, when we program the memory management unit (MMU), we will be
	 able to choose which bits (R=read, W=write, X=execute) we want each memory segment
	 to be able to do.
   */
  .rodata : {
    PROVIDE(_rodata_start = .);
    *(.rodata .rodata.*)
    PROVIDE(_rodata_end = .);
	/*
	   Again, we're placing the rodata section in the memory segment &quot;ram&quot; and we're putting
	   it in the :text program header. We don't have one for rodata anyway.
	*/
  } &gt;ram AT&gt;ram :text

  .data : {
	/*
	   . = ALIGN(4096) tells the linker to align the current memory location (which is
	   0x8000_0000 + text section + rodata section) to 4096 bytes. This is because our paging
	   system's resolution is 4,096 bytes or 4 KiB.
	*/
    . = ALIGN(4096);
    PROVIDE(_data_start = .);
	/*
	   sdata and data are essentially the same thing. However, compilers usually use the
	   sdata sections for shorter, quicker loading sections. So, usually critical data
	   is loaded there. However, we're loading all of this in one fell swoop.
	   So, we're looking to put all of the following sections under the umbrella .data:
	   .sdata
	   .sdata.[anything]
	   .data
	   .data.[anything]

	   ...in that order.
	*/
    *(.sdata .sdata.*) *(.data .data.*)
    PROVIDE(_data_end = .);
  } &gt;ram AT&gt;ram :data

  .bss : {
    PROVIDE(_bss_start = .);
    *(.sbss .sbss.*) *(.bss .bss.*)
    PROVIDE(_bss_end = .);
  } &gt;ram AT&gt;ram :bss

  /*
     The following will be helpful when we allocate the kernel stack (_stack) and
	 determine where the heap begnis and ends (_heap_start and _heap_start + _heap_size)/
	 When we do memory allocation, we can use these symbols.

	 We use the symbols instead of hard-coding an address because this is a floating target.
	 As we add code, the heap moves farther down the memory and gets shorter.

	 _memory_start will be set to 0x8000_0000 here. We use ORIGIN(ram) so that it will take
	 whatever we set the origin of ram to. Otherwise, we'd have to change it more than once
	 if we ever stray away from 0x8000_0000 as our entry point.
  */
  PROVIDE(_memory_start = ORIGIN(ram));
  /*
     Our kernel stack starts at the end of the bss segment (_bss_end). However, we're allocating
	 0x80000 bytes (524 KiB) to our kernel stack. This should be PLENTY of space. The reason
	 we add the memory is because the stack grows from higher memory to lower memory (bottom to top).
	 Therefore we set the stack at the very bottom of its allocated slot.
	 When we go to allocate from the stack, we'll subtract the number of bytes we need.
  */
  PROVIDE(_stack = _bss_end + 0x80000);
  PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram));

  /* 
     Finally, our heap starts right after the kernel stack. This heap will be used mainly
	 to dole out memory for user-space applications. However, in some circumstances, it will
	 be used for kernel memory as well.

	 We don't align here because we let the kernel determine how it wants to do this.
  */
  PROVIDE(_heap_start = _stack);
  PROVIDE(_heap_size = _memory_end - _stack);
}

</code></pre>
<p>Now that our linker script is ready, we need to configure our build settings in the cargo file:<br />
Add the following line to cargo.toml.  That way, we notify the linker about the path to the linker script</p>
<pre><code class="language-bash">[build]
target = &quot;riscv64gc-unknown-none-elf&quot;
rustflags = ['-Clink-arg=-Tsrc/lds/virt.lds']
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-riscv-virtual-environment"><a class="header" href="#setting-up-the-riscv-virtual-environment">Setting up the Riscv Virtual environment</a></h1>
<p><a href="./theory_on_Qemu.html">Crude</a></p>
<p>We will be using the <a href="https://www.qemu.org/docs/master/system/target-riscv.html">Qemu RISC-V System emulator</a> to emulate a RISCV-CPU microcontroller. </p>
<h4 id="how-to-install-qemu-riscv-system-emulator-on-linux-mint"><a class="header" href="#how-to-install-qemu-riscv-system-emulator-on-linux-mint">How to install Qemu RISCV system Emulator on Linux-Mint</a></h4>
<p>At the command type</p>
<pre><code class="language-bash">sudo apt install qemu-user
sudo apt install qemu-system-misc
</code></pre>
<h4 id="qemu-configurations"><a class="header" href="#qemu-configurations">Qemu Configurations</a></h4>
<p>For QEMU’s RISC-V system emulation, you must specify which board model you want to emulate with the -M or --machine option; there is no default. In our case we will emulate the <a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ Generic Virtual Platform </a>as our target board model</p>
<p>When using the sifive_u or virt machine there are three different firmware boot options: </p>
<ol>
<li>-bios default - This is the default behaviour if no -bios option is included. This option will load the default OpenSBI firmware automatically. The firmware is included with the QEMU release and no user interaction is required. All a user needs to do is specify the kernel they want to boot with the -kernel option </li>
<li>-bios none - QEMU will not automatically load any firmware. It is up to the user to load all the images they need. </li>
<li>-bios --file - Tells QEMU to load the specified file as the firmware.</li>
</ol>
<p>We will use the following Qemu configurations ;</p>
<pre><code class="language-bash">// we define some variables 
QEMU=qemu-system-riscv64  // we are using the Riscv Qemu emulator. qemu-system-riscv64 is a variable containing the path to the QEMU executable
MACH=virt                 // we will target the Virt Riscv Machine 
CPU=rv64                  // we will use a 64-bit CPU
CPUS=4                    // The Board will have 4 CPUs... 4 HARTS
MEM=128M                  // The RAM memory will be 128 MBs
DRIVE=hdd.dsk             // This is the path to our virtual harddrive

$(QEMU) -machine $(MACH) 
        -cpu $(CPU) 
        -smp $(CPUS)     // specifies the number of CPUs to emulate
        -m $(MEM)        // specifies the amount of RAM in MBs 
        -nographic       // disables graphical output, so QEMU runs in a terminal window.
        -serial mon:stdio // connects the virtual machine motherboard's serial port to the host's system terminal. Ie, our Linux terminal. This enables us to use the terminal as a console to the virtual machine.
        -bios none       // we not depend on any firmware becaue our machine is virtual. We can just direclty load the OS image to memory. 
        -kernel $(OUT)  // This specifies the path to the kernel image file
        -drive if=none,format=raw,file=$(DRIVE),id=attic // explained below
        -device virtio-blk-device,scsi=off,drive=attic     // explained below
</code></pre>
<pre><code class="language-bash">-drive if=none,format=raw,file=$(DRIVE),id=attic
</code></pre>
<p><strong>'if=none'</strong> meant that Qemu should not create an interface between the hard drive and the Kernel image. An example of an interface is SATA interface.</p>
<p>'<strong>format=raw</strong>' means that the hard drive image should consist of raw bytes to represent data on the disk. The disk should no have extra metadata or compressions.
Other possible values for the format option include:</p>
<ul>
<li>qcow2: This is the default format for disk images in QEMU/KVM, and it supports features like compression, snapshots, and encryption.</li>
<li>mdk: This is a format used by VMware virtualization software.</li>
<li>vpc: This is a format used by Microsoft Virtual PC.</li>
<li>raw: This is similar to format=raw, but it includes a 512-byte header that specifies the disk geometry and other information.</li>
</ul>
<p>The choice of disk image format depends on the specific needs of your virtualization environment. For example, if you need to support snapshots or compression, you would likely choose qcow2. If you need to import or export the image to another virtualization platform, you may need to choose a format that is compatible with that platform.</p>
<pre><code class="language-bash">-device virtio-blk-device,scsi=off,drive=attic
</code></pre>
<p><strong>'-device'</strong> is a Qemu command for attaching new devices to the motherboard of the virtual machine.</p>
<p><strong>virtio-blk-device,scsi=off,drive=attic</strong> implies that we are adding a block device that adheres to VIRTIO protocol. '<strong>scsi=off</strong>' disables the SCSI (Small Computer System Interface), this is because we intend to write a custom virtio block driver. '<strong>drive=attic</strong>' specifies the Identifier of the new device that is being attached.</p>
<h4 id="creating-a-virtual-hard-disk"><a class="header" href="#creating-a-virtual-hard-disk">Creating a virtual hard disk</a></h4>
<p>In the configurations above, it was specified that a virtual hard disk would get attached to the motherboard. It was specified that its path would be ./hdd.dsk</p>
<p>To create this hard disk we use a tool called <a href="https://man7.org/linux/man-pages/man8/losetup.8.html">Losetup</a>. This tool converts a normal text file into a virtual block hard drive.</p>
<p>Losetup creates Loop devices. A loop device is a file that emulates a block device.</p>
<p>Losetup comes pre-installed in any standard linux distribution. To check its documentation, type this in the terminal:</p>
<pre><code class="language-bash">man losetup
</code></pre>
<p>To create a virtual disk within your development working dierctory, write the following command in your terminal: </p>
<pre><code class="language-bash">dd if=/dev/zero of=hdd.dsk count=32 bs=1M  
</code></pre>
<p>where : </p>
<ul>
<li>'<strong>if=/dev/zero</strong>: This option specifies the input file to use for the dd command. In this case, the input file is /dev/zero, which is a special file that produces an endless stream of zeroes when read.</li>
<li><strong>of=hdd.dsk</strong>: This option specifies the output file to create for the dd command. In this case, the output file is called hdd.dsk.</li>
<li><strong>count=32</strong>: This option specifies the number of blocks to copy from the input file to the output file. In this case, 32 blocks of data will be copied.</li>
<li><strong>bs=1M</strong>: This option specifies the block size to use for the dd command. In this case, the block size is 1 megabyte (1M).</li>
</ul>
<p>An alternative set of commands would be :</p>
<pre><code class="language-bash">fallocate --length 32M hdd.dsk  // create a new file called hdd.dsk and allocate to it 32 MB
sudo losetup /dev/loop0 hdd.dsk // convert hdd.dsk into a  virtual hard drive whose mount point is at /dev/loop0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definitions-and-theories"><a class="header" href="#definitions-and-theories">Definitions and Theories</a></h1>
<h4 id="linker"><a class="header" href="#linker">Linker</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-linker-1"><a class="header" href="#the-linker-1">The linker</a></h1>
<h4 id="what-is-a-linker"><a class="header" href="#what-is-a-linker">What is a linker?</a></h4>
<p>A linker is a program that links object files generated by a compiler into an executable or shared library. It resolves external symbols and relocations, and generates the final output file.</p>
<h4 id="what-are-external-symbols"><a class="header" href="#what-are-external-symbols">What are External symbols?</a></h4>
<p>External symbols are variables that get declared in one object file, but they also get used in another different object file. For example, I may declare a global variable 'X' in a header file. If I reference this header file in another file (eg main.rs) and use variable X... that means X has become an external symbol.</p>
<h4 id="what-does-resolving-exernal-symbols-mean"><a class="header" href="#what-does-resolving-exernal-symbols-mean">What does resolving Exernal symbols mean?</a></h4>
<p>In the context of the linker, resolving External symbols means finding the actual memory location or address of a symbol that is referenced by another module, and updating the reference in the module that uses the symbol to point to the correct memory location.</p>
<h4 id="what-is-relocation"><a class="header" href="#what-is-relocation">What is relocation?</a></h4>
<p>Relocation is the act of changing the memory address pointed to by a variable. In the case of a linker, after it has resolved all external symbols, it changes the memory addresses of those external symbols and makes them point to different memory addresses that were specified by the linking script.</p>
<p>So the relocation process adjusts the addresses of symbols in an object file to reflect their final location in memory. In this case, we mean virtual memory addresses... NOT Physical memory addresses.</p>
<h4 id="what-is-this-linking-script"><a class="header" href="#what-is-this-linking-script">What is this linking script?</a></h4>
<p>A linker script is a text file that provides additional instructions to the linker about how to link the input files. It can specify the layout of the output file or the order in which the input files should be linked.</p>
<p><a href="go_back?">crude</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qemu"><a class="header" href="#qemu">Qemu</a></h1>
<p>QEMU is a generic and open source machine emulator and virtualizer.</p>
<p>A machine emulator is a software program that simulates the behaviour of another computer or another computing system. For example you may simulate the behavior of a quantum computer on a convetional computer.</p>
<p>A virtualizer is a program that abstracts an underlying system. The underlying system can be anything : Bare metal cpu, a hard disk, an operating system... anything.</p>
<p>QEMU can be used in several different ways. The most common is for System Emulation, where it provides a virtual model of an entire machine (CPU, memory and emulated devices) to run a guest OS. In this mode the CPU may be fully emulated, or it may work with a hypervisor such as KVM, Xen, Hax or Hypervisor.Framework to allow the guest to run directly on the host CPU.</p>
<p>The second supported way to use QEMU is User Mode Emulation, where QEMU can launch processes compiled for one CPU on another CPU. In this mode the CPU is always emulated.</p>
<p>In our project, we will use Qemu as a <a href="https://www.qemu.org/docs/master/system/target-riscv.html">Riscv System Emulator</a>. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
