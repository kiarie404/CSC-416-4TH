<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming_the_UART - Developer Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="setting_things_up.html"><strong aria-hidden="true">1.</strong> Setting Things Up</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up_the_compiler.html"><strong aria-hidden="true">1.1.</strong> Setting up the compiler</a></li><li class="chapter-item expanded "><a href="setting_up_LLD_linker.html"><strong aria-hidden="true">1.2.</strong> Setting up the linker</a></li><li class="chapter-item expanded "><a href="setting_up_qemu.html"><strong aria-hidden="true">1.3.</strong> Setting up the Riscv Virtual environment</a></li><li class="chapter-item expanded "><a href="setting_up_build_automation.html"><strong aria-hidden="true">1.4.</strong> Setting up the Build automation tool</a></li></ol></li><li class="chapter-item expanded "><a href="writing_a_bare_metal_rust_executable.html"><strong aria-hidden="true">2.</strong> writing a bare metal Rust executable</a></li><li class="chapter-item expanded "><a href="boot_design.html"><strong aria-hidden="true">3.</strong> boot_design</a></li><li class="chapter-item expanded "><a href="boot_designs.html"><strong aria-hidden="true">4.</strong> Boot Design</a></li><li class="chapter-item expanded "><a href="the_bootloader.html"><strong aria-hidden="true">5.</strong> The Bootloader</a></li><li class="chapter-item expanded "><a href="the_bootloader_2.html"><strong aria-hidden="true">6.</strong> The Bootloader_2</a></li><li class="chapter-item expanded "><a href="setting_up_comunications.html"><strong aria-hidden="true">7.</strong> Setting Up Communications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="designs_and_layouts.html"><strong aria-hidden="true">7.1.</strong> Designs and layouts</a></li><li class="chapter-item expanded "><a href="general_theory_on_communication.html"><strong aria-hidden="true">7.2.</strong> General Theory on communication</a></li><li class="chapter-item expanded "><a href="the_uart_theory.html"><strong aria-hidden="true">7.3.</strong> The UART </a></li><li class="chapter-item expanded "><a href="more_about_the_UART.html"><strong aria-hidden="true">7.4.</strong> More About the UART</a></li><li class="chapter-item expanded "><a href="programming_the_UART.html" class="active"><strong aria-hidden="true">7.5.</strong> Programming_the_UART</a></li></ol></li><li class="chapter-item expanded "><a href="theory_on_paging.html"><strong aria-hidden="true">8.</strong> Theory on Paging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="segmentation.html"><strong aria-hidden="true">8.1.</strong> segmentation</a></li><li class="chapter-item expanded "><a href="paging.html"><strong aria-hidden="true">8.2.</strong> paging</a></li></ol></li><li class="chapter-item expanded "><a href="setting_up_memory_management.html"><strong aria-hidden="true">9.</strong> Setting Up Memory Management</a></li><li class="chapter-item expanded "><a href="memory_designs.html"><strong aria-hidden="true">10.</strong> Designs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RAM_management.html"><strong aria-hidden="true">10.1.</strong> The RAM Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abstracting_the_RAM.html"><strong aria-hidden="true">10.1.1.</strong> Abstracting the RAM</a></li><li class="chapter-item expanded "><a href="allocation_and_deallocation_RAM.html"><strong aria-hidden="true">10.1.2.</strong> Allocating RAM Memory</a></li><li class="chapter-item expanded "><a href="fine_grained_alloation.html"><strong aria-hidden="true">10.1.3.</strong> Byte-grained allocation</a></li><li class="chapter-item expanded "><a href="setting_up_memory_virtualization_and_access_management.html"><strong aria-hidden="true">10.1.4.</strong> Setting Up RAM Memory Virtualization and access_management</a></li><li class="chapter-item expanded "><a href="handling_the_Physical_MMU.html"><strong aria-hidden="true">10.1.5.</strong> Using the Physical MMU instead of Virtual MMU</a></li><li class="chapter-item expanded "><a href="actual_implementation.html"><strong aria-hidden="true">10.1.6.</strong> Actual_implementation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="handling_interrupts_and_traps.html"><strong aria-hidden="true">11.</strong> Handling interrupts and Traps</a></li><li class="chapter-item expanded "><a href="handling_interrupts_and_traps_2.html"><strong aria-hidden="true">12.</strong> Handling interrupts and Traps 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_each_exceptions_were_handled.html"><strong aria-hidden="true">12.1.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="timer_interrupt.html"><strong aria-hidden="true">12.2.</strong> Timer_interrupt</a></li><li class="chapter-item expanded "><a href="external_interrupt.html"><strong aria-hidden="true">12.3.</strong> External Interrupt</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="uart_interrupt.html"><strong aria-hidden="true">12.3.1.</strong> UART Interrupt</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="handling_external_interrupts.html"><strong aria-hidden="true">13.</strong> Handling External Interrupts</a></li><li class="chapter-item expanded "><a href="setting_up_processes.html"><strong aria-hidden="true">14.</strong> Setting up Processes</a></li><li class="chapter-item expanded "><a href="processes.html"><strong aria-hidden="true">15.</strong> Processes Version 2</a></li><li class="chapter-item expanded "><a href="the_block_driver.html"><strong aria-hidden="true">16.</strong> The Block Driver</a></li><li class="chapter-item expanded "><a href="system_calls.html"><strong aria-hidden="true">17.</strong> system_calls</a></li><li class="chapter-item expanded "><a href="Filesystem.html"><strong aria-hidden="true">18.</strong> Filesystem</a></li><li class="chapter-item expanded "><a href="user_processes.html"><strong aria-hidden="true">19.</strong> User Processes</a></li><li class="chapter-item expanded "><a href="overall_design.html"><strong aria-hidden="true">20.</strong> Overall Design</a></li><li class="chapter-item expanded "><a href="definitions_and_theories.html"><strong aria-hidden="true">21.</strong> Definitions and Theories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="theory_on_the_linker.html"><strong aria-hidden="true">21.1.</strong> The linker</a></li><li class="chapter-item expanded "><a href="theory_on_Qemu.html"><strong aria-hidden="true">21.2.</strong> Qemu</a></li><li class="chapter-item expanded "><a href="fragmentation_issues.html"><strong aria-hidden="true">21.3.</strong> fragmentation_issues</a></li><li class="chapter-item expanded "><a href="memory_tracking_mechanisms.html"><strong aria-hidden="true">21.4.</strong> Memory Tracking Mechanisms</a></li><li class="chapter-item expanded "><a href="theory_on_MMU_implementation_in_riscv.html"><strong aria-hidden="true">21.5.</strong> Theory on MMU implementation in Riscv</a></li><li class="chapter-item expanded "><a href="VirtIO.html"><strong aria-hidden="true">21.6.</strong> VirtIO</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Miscellenious</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">22.1.</strong> Error Numbers</a></li><li class="chapter-item expanded "><a href="measuring_software_performance.html"><strong aria-hidden="true">22.2.</strong> Measuring Performance of software</a></li><li class="chapter-item expanded "><a href="importing_variables_from_the_linker_script.html"><strong aria-hidden="true">22.3.</strong> Importing variables from the Linker script</a></li><li class="chapter-item expanded "><a href="GNU_assembly_macros.html"><strong aria-hidden="true">22.4.</strong> GNU assembly macros</a></li><li class="chapter-item expanded "><a href="the_singleton_design.html"><strong aria-hidden="true">22.5.</strong> The singleton Structure</a></li><li class="chapter-item expanded "><a href="multitasking.html"><strong aria-hidden="true">22.6.</strong> Multitasking</a></li><li class="chapter-item expanded "><a href="Bitmasking_and_bit_operations.html"><strong aria-hidden="true">22.7.</strong> Bitmasking_and_bit_operations</a></li><li class="chapter-item expanded "><a href="compressed_instructions.html"><strong aria-hidden="true">22.8.</strong> Compressed Instructions</a></li><li class="chapter-item expanded "><a href="the_ABI.html"><strong aria-hidden="true">22.9.</strong> The ABI</a></li><li class="chapter-item expanded "><a href="ELF_files.html"><strong aria-hidden="true">22.10.</strong> Elf Files</a></li><li class="chapter-item expanded "><a href="riscv_registers.html"><strong aria-hidden="true">22.11.</strong> Riscv_registers</a></li><li class="chapter-item expanded "><a href="virt.html"><strong aria-hidden="true">22.12.</strong> Virtual representation of riscv in Qemu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pcie_express_devices.html"><strong aria-hidden="true">22.12.1.</strong> PCIe express devices</a></li><li class="chapter-item expanded "><a href="virtio_devices.html"><strong aria-hidden="true">22.12.2.</strong> VIRTIO devices</a></li></ol></li><li class="chapter-item expanded "><a href="global_allocator.html"><strong aria-hidden="true">22.13.</strong> Global Allocator</a></li><li class="chapter-item expanded "><a href="falling_to_fly.html"><strong aria-hidden="true">22.14.</strong> Falling_to_fly</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> AfterMath</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="buffer_overflow_attacks.html"><strong aria-hidden="true">23.1.</strong> buffer_overflow_attacks</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> fork_bomb</div></li></ol></li><li class="chapter-item expanded "><a href="web_assembly.html"><strong aria-hidden="true">24.</strong> Web Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="literature_review_papers.html"><strong aria-hidden="true">24.1.</strong> Literature review papers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="software_deployment.html"><strong aria-hidden="true">24.1.1.</strong> Software_deployment</a></li></ol></li><li class="chapter-item expanded "><a href="setting_up_wasm_runtime.html"><strong aria-hidden="true">24.2.</strong> Setting Up Wasm Runtime</a></li><li class="chapter-item expanded "><a href="webassembly_challenges.html"><strong aria-hidden="true">24.3.</strong> webassembly_challenges</a></li><li class="chapter-item expanded "><a href="the_wasm_book.html"><strong aria-hidden="true">24.4.</strong> The Book</a></li><li class="chapter-item expanded "><a href="wasm_runtimes_in_no_std_environments.html"><strong aria-hidden="true">24.5.</strong> Using A Wasm Runtime in a no-std environment</a></li></ol></li><li class="chapter-item expanded "><a href="RISCV_RUN.html"><strong aria-hidden="true">25.</strong> RISCV_RUN</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reasons_for_RISCV.html"><strong aria-hidden="true">25.1.</strong> reasons_for_RISCV</a></li><li class="chapter-item expanded "><a href="priviledged_architecture.html"><strong aria-hidden="true">25.2.</strong> priviledged_architecture</a></li><li class="chapter-item expanded "><a href="error_handling_in_machine_mode.html"><strong aria-hidden="true">25.3.</strong> error_handling_in_machine_mode</a></li><li class="chapter-item expanded "><a href="seperating_user_mode_from_machine_mode.html"><strong aria-hidden="true">25.4.</strong> seperating_user_mode_from_machine_mode</a></li><li class="chapter-item expanded "><a href="Supervisor_mode_to_the_rescue.html"><strong aria-hidden="true">25.5.</strong> Supervisor_mode_to_the_rescue</a></li><li class="chapter-item expanded "><a href="learning_magic.html"><strong aria-hidden="true">25.6.</strong> Learning_magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">25.6.1.</strong> resources</a></li><li class="chapter-item expanded "><a href="random_notes.html"><strong aria-hidden="true">25.6.2.</strong> random_notes</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">26.</strong> References</a></li><li class="chapter-item expanded "><a href="problem_statement.html"><strong aria-hidden="true">27.</strong> Problem_statement</a></li><li class="chapter-item expanded "><a href="implementations.html"><strong aria-hidden="true">28.</strong> Implementations</a></li><li class="chapter-item expanded "><a href="debugging_in_rust.html"><strong aria-hidden="true">29.</strong> Debugging in Rust</a></li><li class="chapter-item expanded "><a href="qemu_configurations.html"><strong aria-hidden="true">30.</strong> Qemu Configurations</a></li><li class="chapter-item expanded "><a href="link_scripts.html"><strong aria-hidden="true">31.</strong> Link Scripts</a></li><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">32.</strong> Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mermaid.js.html"><strong aria-hidden="true">32.1.</strong> mermaid</a></li></ol></li><li class="chapter-item expanded "><a href="testing_guide.html"><strong aria-hidden="true">33.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no_std_testing.html"><strong aria-hidden="true">33.1.</strong> No-Std Testing</a></li><li class="chapter-item expanded "><a href="unit_tests.html"><strong aria-hidden="true">33.2.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="integration_tests.html"><strong aria-hidden="true">33.3.</strong> Integration Tests</a></li></ol></li><li class="chapter-item expanded "><a href="Debugging.html"><strong aria-hidden="true">34.</strong> Debugging</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programming_the_uart"><a class="header" href="#programming_the_uart">Programming_the_UART</a></h1>
<h4 id="initializing-the-communication-between-the-2-devices"><a class="header" href="#initializing-the-communication-between-the-2-devices">Initializing the Communication between the 2 devices.</a></h4>
<p>Initializing the communications between the 2 devices means that we configure the UART protocol.<br />
We need to define :</p>
<ol>
<li>The maximum amount of bits that can be contained in the buffer at a time. The 2 devices need to agree on this so that data does not get lost if one of the devices buffer is too small.</li>
<li>Set the order of reading and writing to the communication buffer. In our case, we set the order to FIFO (First in First Out).</li>
<li>Define how the CPU and the UART will communicate with each other when the buffer is ready to be read or written to. You can choose between 2 methods ; Poll driven communication od Interrupt driven communication.<br />
In Interrupt driven communication, the UART device sends interrupt signals to the CPU whenever the read buffer is full. And consequently, the CPU invokes the appropriate interrupt handler. You have the option to involve the PLIC or not.<br />
In the Poll driven communication, the CPU will occasionally check if the buffer is ready to be read or written to.</li>
<li>Set the data transfer speed between the 2 devices - the baud rate. This is to avoid data loss.</li>
</ol>
<p>But here is a relief : If we set the DLAB (Divisor Latch access bit) to zero, then :</p>
<ul>
<li>The Prescaler Division Register becomes inaccessible. Meaning that the Line status register does not have to share the byte space.</li>
<li>The DLL register becomes inaccessible, meaning the RHR and THR don't have to share the byte space.</li>
<li>The DLM register becomes inaccessible, meaning that the Interrupt Enable Register does not have to share the byte space.</li>
</ul>
<p>That is the path we will take, we will set the DLAB bit to zero so that we access the registers in a more simple manner. The reason that makes it okay to disregard setting the DLL, DLM and PDS registers is because we do not need them. These three registers are used to set the Baud Rate of the UART device.</p>
<p>We are in Qemu, this is a virtual space. This means that we are not dealing with real physical devices. Because of this fact, it is not necessary to set the Baud Rate. The machine emulates the maximum baud rate available.</p>
<p>The Baud Rate formula is as follows :<br />
Divisor = UART_device_clock_frequency / ( Baud_rate x Prescaler_Division_value)</p>
<p>where :</p>
<ul>
<li>Divisor is a 16 bit value whose first 8 bits get stored in the DLM register and last 8 bits get stored in the DLL register. If we do not set the DLL and DLM bit, the Divisor value is assumed to be  65,536 (2^16).</li>
<li>UART_device_clock_frequency is the clock speed of the particular UART implementation. eg 16MHz</li>
<li>The Baud_rate is the rate at which data transfers, this is what we are trying to calulate.</li>
<li>The Prescaler_Division_value is found in the Prescaler_Division register. It is represented using 4 bits, its value ranges from 1 to 16. If we do not set the prescaler division value, 16 is assumed to be the default. We are okay with 16</li>
</ul>
<p>We will use this registers to :</p>
<ol>
<li>Initialize the communication between the 2 devices</li>
<li>fetch and write data to the communication buffers</li>
</ol>
<h5 id="pseudocode-for-initializing-the-uart-communication"><a class="header" href="#pseudocode-for-initializing-the-uart-communication">Pseudocode for initializing the UART communication</a></h5>
<p>input : the UART base address (hopefully from a struct abstract)
output : No_output</p>
<ol>
<li>set the word length to 8 bits
<ul>
<li>access the lCR register</li>
<li>set bits [1:0] to [1:1]</li>
</ul>
</li>
<li>Enable FIFO reads and writes
<ul>
<li>access the FIcaler Division RegisFO control Register</li>
<li>turn the FIFO enable bit to 1</li>
</ul>
</li>
<li>Set the interrupt capability 
<ul>
<li>Access the Interupt enable Register</li>
<li>enable the data ready interrupt [set bit 0 to the value 1]</li>
<li>enable the transmitter empty interrupt [set bit 1 to the value 1]</li>
</ul>
</li>
<li>Set the Baud rate
<ul>
<li>since we are setting the BAUD rate at 2400, the divisor value is 592</li>
<li>use bitmasking to separate the most sigificant bytes from the least significant bytes</li>
<li>Set the DLAB bit to 1 in order to allow setting the Baud rate</li>
<li>store the two seperate values in the DLL and DLM respectively</li>
</ul>
</li>
</ol>
<h4 id="reading-from-the-uart"><a class="header" href="#reading-from-the-uart">Reading from the UART</a></h4>
<p>When the buffer is full, the UART sends an interrupt to the PLIC. The PLIC calls the interrupt handler. The Interrupt handler invokes a UART read (This function that we are writing now). The read input can be directly displayed in the console output or stored in a buffer</p>
<h5 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h5>
<p>input : the UART base address (hopefully from a struct abstract)
output : Option&lt;None, BYTE&gt;</p>
<ol>
<li>Access the Line Status Register</li>
<li>Access the data_ready status bit.</li>
<li>If the data Bit is 1, continue to step 5</li>
<li>If the data bit is 0, return None</li>
<li>Read the RHR buffer and return the read byte.</li>
</ol>
<p>When the interrupt handler calles read function, it stores the inputs in a curcular buffer. From this buffer you can choose hich inputs to display to the console or process</p>
<h5 id="control-flow-diagram-of-the-uart-read"><a class="header" href="#control-flow-diagram-of-the-uart-read">Control flow diagram of the UART read</a></h5>
<pre class="mermaid">    graph TD
        A[ Access the Line Status Register] --&gt; B[Access the data_ready status bit];
        B --&gt; C{Is the Data Ready?} ;
        C --&gt; |Yes| D[Read the RHR buffer];
        D --&gt; E[return the read byte];
        C --&gt; |No| E[return None type]
</pre>
<h4 id="writing-the-uart"><a class="header" href="#writing-the-uart">Writing the UART</a></h4>
<p>When the buffer is empty, the UART sends an interrupt to the PLIC. The PLIC calls the interrupt handler. The Interrupt handler checks if the UART_console_write_buffer is empty. If the Buffer is empty, the Interrupt handler does not call the UART_write function.
If the UART_console_write_buffer is not empty, the interrupt handler calls the console_output_feeder.</p>
<h5 id="pseudocode-1"><a class="header" href="#pseudocode-1">Pseudocode</a></h5>
<p>input : the UART base address (hopefully from a struct abstract), the byte to be written
output : Result&lt;Ok, Err&gt;</p>
<ol>
<li>Access the Line Status Register</li>
<li>Confirm that the THR is empty</li>
<li>If the data Bit is 1, continue to step 5</li>
<li>If the data bit is 0, return Err</li>
<li>Write to the THR buffer and return an OK().</li>
</ol>
<p>When the interrupt handler calles read function, it stores the inputs in a curcular buffer. From this buffer you can choose hich inputs to display to the console or process</p>
<h5 id="control-flow-diagram-of-the-uart-read-1"><a class="header" href="#control-flow-diagram-of-the-uart-read-1">Control flow diagram of the UART read</a></h5>
<pre class="mermaid">    graph TD
        A[ Access the Line Status Register] --&gt; B[Access the THR_Empty status bit];
        B --&gt; C{Is the THR Empty?} ;
        C --&gt; |Yes| D[Write to the THR buffer];
        D --&gt; E[return an OK];
        C --&gt; |No| F[return Err]
</pre>
<h4 id="uart-buffer-management"><a class="header" href="#uart-buffer-management">UART Buffer management</a></h4>
<p>Data coming from the keyboard can either be displayed to the console or stored for further processing. For this reason we will have a ring buffer for storing read input. Whatever you choose to do with this data is up to you</p>
<p>With this input buffer, we can implement scanf. 
We can also confortably implement a function that continuously reacts keyboard input. (eg, continuous console display)</p>
<p>Data coming from the programs might also need to be displayed . That is why we have the UART_console_write_buffer. Strings from the user or kernel programs get stored in this queue. From there, when we receive a THR_empty interrupt, </p>
<h4 id="driver-exposed-api"><a class="header" href="#driver-exposed-api">Driver exposed API</a></h4>
<ul>
<li>Clear input buffer (everyone)</li>
<li>Read input buffer (everyone)</li>
<li>Read line  (Everyone)</li>
<li>Read word  (Everyone)</li>
<li>Write word (Everyone)</li>
<li>Write line (Everyone)</li>
<li>Determine interrupt type (User PLIC)</li>
</ul>
<h4 id="interaction-with-the-plic"><a class="header" href="#interaction-with-the-plic">Interaction with the PLIC</a></h4>
<p>The PLIC receives interrupts from the UART whenever the Data Buffer is full_and_ready_to_be_read. When the PLIC receives this interrupt, it does not really know what the interrupt is all about. So it needs to read in the UART Line Status Register and determine which event caused the interrupt. This situation is valid only when the UART is set to send interrupts because of many reasons.</p>
<p>However in our case, the PLIC sends interrupts only when Data Buffer is full_and_ready_to_be_read, so we do not need a function to determine the type of interrupt. the type of interrupt is always &quot;data Ready&quot;</p>
<h3 id="principles-when-abstracting-hardware"><a class="header" href="#principles-when-abstracting-hardware">Principles when abstracting hardware</a></h3>
<ol>
<li>The struct used to abstract the hardware MMIO map should be compiled in a predictable manner (C ABI)</li>
<li>We should always use volatile reads and writes to the MMIO registers</li>
<li>In software, we should be able to share any number of read-only accesses to these peripherals</li>
<li>If some software should have read-write access to a peripheral, it should hold the only reference to that peripheral</li>
</ol>
<h4 id="why-use-the-c-abi"><a class="header" href="#why-use-the-c-abi">Why use the C ABI?</a></h4>
<p>The C ABI is used for the sake of compatibility and predictability. For example, the Rust struct fields can get re-ordered while the C structs field order is static. For example, if a struct field has 2 integer fields and 1 boolean, normally the field order would be as declared. But if the boolean is accessed more frequently, it might be re-odered and placed at the beginning to improve cache locality.<br />
In this case, we need the struct order as static.</p>
<h4 id="why-use-volatile-reads-and-writes"><a class="header" href="#why-use-volatile-reads-and-writes">Why use volatile reads and writes?</a></h4>
<p>When you write to the same memory address for a couple of times, the compiler might optimize the code and just consider the last write value. Meaning you will lose a couple of writes due to compiler optimization.</p>
<p>When you read from the same memory a couple of times, the compiler might optimize the reads using a cache;
Volatile read the image, there are onl</p>
<h4 id="why-we-wont-use-global-mutable-variables-to-abstract-our-uart-driver"><a class="header" href="#why-we-wont-use-global-mutable-variables-to-abstract-our-uart-driver">Why we won't use global mutable variables to abstract our UART driver</a></h4>
<p>In Rust, global mutable variables are considered unsafe. You have to enclose any interactions with them using the unsafe block.<br />
They are unsafe because :</p>
<ol>
<li>They can lead to data races when multiple threads have r/w access to it. --&gt; </li>
<li>They can lead to memory unsafety. 
<ul>
<li>If the global variable is uninitialized and a read operation is executed, it may cause a null dereferencing problem. There is a chance of this happening because the thread that was taking care of initialization did not execute before the thread that read the global variable.</li>
<li>If the global variable is not initialized in a timely manner, a write to the location may cause a bufferoverflow.</li>
</ul>
</li>
<li>It is hard to organize code that is full of global mutable variables. It is hard to debug such a program.</li>
</ol>
<p>So ... moral lesson : Try your best to never use global mutable variables.</p>
<p>We can implement the 3rd and 4th <a href="#principles-when-abstracting-hardware">Principles</a> using the Singleton structure. Our singleton strategy is not thread safe (undone)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="more_about_the_UART.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="theory_on_paging.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="more_about_the_UART.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="theory_on_paging.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </body>
</html>
