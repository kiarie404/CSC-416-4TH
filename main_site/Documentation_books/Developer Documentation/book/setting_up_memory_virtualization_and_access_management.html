<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Setting Up RAM Memory Virtualization and access_management - Developer Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="setting_things_up.html"><strong aria-hidden="true">1.</strong> Setting Things Up</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up_the_compiler.html"><strong aria-hidden="true">1.1.</strong> Setting up the compiler</a></li><li class="chapter-item expanded "><a href="setting_up_LLD_linker.html"><strong aria-hidden="true">1.2.</strong> Setting up the linker</a></li><li class="chapter-item expanded "><a href="setting_up_qemu.html"><strong aria-hidden="true">1.3.</strong> Setting up the Riscv Virtual environment</a></li><li class="chapter-item expanded "><a href="setting_up_build_automation.html"><strong aria-hidden="true">1.4.</strong> Setting up the Build automation tool</a></li></ol></li><li class="chapter-item expanded "><a href="writing_a_bare_metal_rust_executable.html"><strong aria-hidden="true">2.</strong> writing a bare metal Rust executable</a></li><li class="chapter-item expanded "><a href="the_bootloader.html"><strong aria-hidden="true">3.</strong> The Bootloader</a></li><li class="chapter-item expanded "><a href="the_bootloader_2.html"><strong aria-hidden="true">4.</strong> The Bootloader_2</a></li><li class="chapter-item expanded "><a href="setting_up_comunications.html"><strong aria-hidden="true">5.</strong> Setting Up Communications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="designs_and_layouts.html"><strong aria-hidden="true">5.1.</strong> Designs and layouts</a></li><li class="chapter-item expanded "><a href="general_theory_on_communication.html"><strong aria-hidden="true">5.2.</strong> General Theory on communication</a></li><li class="chapter-item expanded "><a href="the_uart_theory.html"><strong aria-hidden="true">5.3.</strong> The UART </a></li><li class="chapter-item expanded "><a href="more_about_the_UART.html"><strong aria-hidden="true">5.4.</strong> More About the UART</a></li><li class="chapter-item expanded "><a href="programming_the_UART.html"><strong aria-hidden="true">5.5.</strong> Programming_the_UART</a></li></ol></li><li class="chapter-item expanded "><a href="theory_on_paging.html"><strong aria-hidden="true">6.</strong> Theory on Paging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="segmentation.html"><strong aria-hidden="true">6.1.</strong> segmentation</a></li><li class="chapter-item expanded "><a href="paging.html"><strong aria-hidden="true">6.2.</strong> paging</a></li></ol></li><li class="chapter-item expanded "><a href="setting_up_memory_management.html"><strong aria-hidden="true">7.</strong> Setting Up Memory Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RAM_management.html"><strong aria-hidden="true">7.1.</strong> The RAM Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abstracting_the_RAM.html"><strong aria-hidden="true">7.1.1.</strong> Abstracting the RAM</a></li><li class="chapter-item expanded "><a href="allocation_and_deallocation_RAM.html"><strong aria-hidden="true">7.1.2.</strong> Allocating RAM Memory</a></li><li class="chapter-item expanded "><a href="fine_grained_alloation.html"><strong aria-hidden="true">7.1.3.</strong> Byte-grained allocation</a></li><li class="chapter-item expanded "><a href="setting_up_memory_virtualization_and_access_management.html" class="active"><strong aria-hidden="true">7.1.4.</strong> Setting Up RAM Memory Virtualization and access_management</a></li><li class="chapter-item expanded "><a href="handling_the_Physical_MMU.html"><strong aria-hidden="true">7.1.5.</strong> Using the Physical MMU instead of Virtual MMU</a></li><li class="chapter-item expanded "><a href="actual_implementation.html"><strong aria-hidden="true">7.1.6.</strong> Actual_implementation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="handling_interrupts_and_traps.html"><strong aria-hidden="true">8.</strong> Handling interrupts and Traps</a></li><li class="chapter-item expanded "><a href="handling_interrupts_and_traps_2.html"><strong aria-hidden="true">9.</strong> Handling interrupts and Traps 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_each_exceptions_were_handled.html"><strong aria-hidden="true">9.1.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="timer_interrupt.html"><strong aria-hidden="true">9.2.</strong> Timer_interrupt</a></li><li class="chapter-item expanded "><a href="external_interrupt.html"><strong aria-hidden="true">9.3.</strong> External Interrupt</a></li></ol></li><li class="chapter-item expanded "><a href="handling_external_interrupts.html"><strong aria-hidden="true">10.</strong> Handling External Interrupts</a></li><li class="chapter-item expanded "><a href="setting_up_processes.html"><strong aria-hidden="true">11.</strong> Setting up Processes</a></li><li class="chapter-item expanded "><a href="the_block_driver.html"><strong aria-hidden="true">12.</strong> The Block Driver</a></li><li class="chapter-item expanded "><a href="system_calls.html"><strong aria-hidden="true">13.</strong> system_calls</a></li><li class="chapter-item expanded "><a href="Filesystem.html"><strong aria-hidden="true">14.</strong> Filesystem</a></li><li class="chapter-item expanded "><a href="user_processes.html"><strong aria-hidden="true">15.</strong> User Processes</a></li><li class="chapter-item expanded "><a href="overall_design.html"><strong aria-hidden="true">16.</strong> Overall Design</a></li><li class="chapter-item expanded "><a href="definitions_and_theories.html"><strong aria-hidden="true">17.</strong> Definitions and Theories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="theory_on_the_linker.html"><strong aria-hidden="true">17.1.</strong> The linker</a></li><li class="chapter-item expanded "><a href="theory_on_Qemu.html"><strong aria-hidden="true">17.2.</strong> Qemu</a></li><li class="chapter-item expanded "><a href="fragmentation_issues.html"><strong aria-hidden="true">17.3.</strong> fragmentation_issues</a></li><li class="chapter-item expanded "><a href="memory_tracking_mechanisms.html"><strong aria-hidden="true">17.4.</strong> Memory Tracking Mechanisms</a></li><li class="chapter-item expanded "><a href="theory_on_MMU_implementation_in_riscv.html"><strong aria-hidden="true">17.5.</strong> Theory on MMU implementation in Riscv</a></li><li class="chapter-item expanded "><a href="VirtIO.html"><strong aria-hidden="true">17.6.</strong> VirtIO</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Miscellenious</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">18.1.</strong> Error Numbers</a></li><li class="chapter-item expanded "><a href="measuring_software_performance.html"><strong aria-hidden="true">18.2.</strong> Measuring Performance of software</a></li><li class="chapter-item expanded "><a href="importing_variables_from_the_linker_script.html"><strong aria-hidden="true">18.3.</strong> Importing variables from the Linker script</a></li><li class="chapter-item expanded "><a href="GNU_assembly_macros.html"><strong aria-hidden="true">18.4.</strong> GNU assembly macros</a></li><li class="chapter-item expanded "><a href="the_singleton_design.html"><strong aria-hidden="true">18.5.</strong> The singleton Structure</a></li><li class="chapter-item expanded "><a href="multitasking.html"><strong aria-hidden="true">18.6.</strong> Multitasking</a></li><li class="chapter-item expanded "><a href="Bitmasking_and_bit_operations.html"><strong aria-hidden="true">18.7.</strong> Bitmasking_and_bit_operations</a></li><li class="chapter-item expanded "><a href="compressed_instructions.html"><strong aria-hidden="true">18.8.</strong> Compressed Instructions</a></li><li class="chapter-item expanded "><a href="the_ABI.html"><strong aria-hidden="true">18.9.</strong> The ABI</a></li><li class="chapter-item expanded "><a href="ELF_files.html"><strong aria-hidden="true">18.10.</strong> Elf Files</a></li><li class="chapter-item expanded "><a href="riscv_registers.html"><strong aria-hidden="true">18.11.</strong> Riscv_registers</a></li><li class="chapter-item expanded "><a href="virt.html"><strong aria-hidden="true">18.12.</strong> Virtual representation of riscv in Qemu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pcie_express_devices.html"><strong aria-hidden="true">18.12.1.</strong> PCIe express devices</a></li><li class="chapter-item expanded "><a href="virtio_devices.html"><strong aria-hidden="true">18.12.2.</strong> VIRTIO devices</a></li></ol></li><li class="chapter-item expanded "><a href="global_allocator.html"><strong aria-hidden="true">18.13.</strong> Global Allocator</a></li><li class="chapter-item expanded "><a href="falling_to_fly.html"><strong aria-hidden="true">18.14.</strong> Falling_to_fly</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> AfterMath</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="buffer_overflow_attacks.html"><strong aria-hidden="true">19.1.</strong> buffer_overflow_attacks</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.2.</strong> fork_bomb</div></li></ol></li><li class="chapter-item expanded "><a href="web_assembly.html"><strong aria-hidden="true">20.</strong> Web Assembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="literature_review_papers.html"><strong aria-hidden="true">20.1.</strong> Literature review papers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="software_deployment.html"><strong aria-hidden="true">20.1.1.</strong> Software_deployment</a></li></ol></li><li class="chapter-item expanded "><a href="setting_up_wasm_runtime.html"><strong aria-hidden="true">20.2.</strong> Setting Up Wasm Runtime</a></li><li class="chapter-item expanded "><a href="webassembly_challenges.html"><strong aria-hidden="true">20.3.</strong> webassembly_challenges</a></li><li class="chapter-item expanded "><a href="the_wasm_book.html"><strong aria-hidden="true">20.4.</strong> The Book</a></li></ol></li><li class="chapter-item expanded "><a href="RISCV_RUN.html"><strong aria-hidden="true">21.</strong> RISCV_RUN</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reasons_for_RISCV.html"><strong aria-hidden="true">21.1.</strong> reasons_for_RISCV</a></li><li class="chapter-item expanded "><a href="priviledged_architecture.html"><strong aria-hidden="true">21.2.</strong> priviledged_architecture</a></li><li class="chapter-item expanded "><a href="error_handling_in_machine_mode.html"><strong aria-hidden="true">21.3.</strong> error_handling_in_machine_mode</a></li><li class="chapter-item expanded "><a href="seperating_user_mode_from_machine_mode.html"><strong aria-hidden="true">21.4.</strong> seperating_user_mode_from_machine_mode</a></li><li class="chapter-item expanded "><a href="Supervisor_mode_to_the_rescue.html"><strong aria-hidden="true">21.5.</strong> Supervisor_mode_to_the_rescue</a></li><li class="chapter-item expanded "><a href="learning_magic.html"><strong aria-hidden="true">21.6.</strong> Learning_magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">21.6.1.</strong> resources</a></li><li class="chapter-item expanded "><a href="random_notes.html"><strong aria-hidden="true">21.6.2.</strong> random_notes</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">22.</strong> References</a></li><li class="chapter-item expanded "><a href="problem_statement.html"><strong aria-hidden="true">23.</strong> Problem_statement</a></li><li class="chapter-item expanded "><a href="implementations.html"><strong aria-hidden="true">24.</strong> Implementations</a></li><li class="chapter-item expanded "><a href="debugging_in_rust.html"><strong aria-hidden="true">25.</strong> Debugging in Rust</a></li><li class="chapter-item expanded "><a href="qemu_configurations.html"><strong aria-hidden="true">26.</strong> Qemu Configurations</a></li><li class="chapter-item expanded "><a href="link_scripts.html"><strong aria-hidden="true">27.</strong> Link Scripts</a></li><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">28.</strong> Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mermaid.js.html"><strong aria-hidden="true">28.1.</strong> mermaid</a></li></ol></li><li class="chapter-item expanded "><a href="testing_guide.html"><strong aria-hidden="true">29.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no_std_testing.html"><strong aria-hidden="true">29.1.</strong> No-Std Testing</a></li><li class="chapter-item expanded "><a href="unit_tests.html"><strong aria-hidden="true">29.2.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="integration_tests.html"><strong aria-hidden="true">29.3.</strong> Integration Tests</a></li></ol></li><li class="chapter-item expanded "><a href="Debugging.html"><strong aria-hidden="true">30.</strong> Debugging</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>In the previous section we did the following :</p>
<ol>
<li>We abstracted the heap memory as pages that are associated to descriptors.</li>
<li>We provided the allocation and deallocation functions</li>
</ol>
<p>In the previous module we were dealing with Physical addresses. We were executing code while the CPU was in Machine mode. This means that the memory management unit was turned off. Our code was referencing live physical addresses. eg memory_start = 0x8000000</p>
<p>In this module we want to abstract the physical RAM. We will virtualize all the memory addresses of the RAM. In real life the RISCV board provides a hardware implementation of a Memory management unit. So this unit provides a way to create virtual addresses and a way to declare access rights to those addresses. The MMU can operate in Bare Mode, SV39 mode or SV48 mode.</p>
<p>Here is a theory discussion of the <a href="./theory_on_MMU_implementation_in_riscv.html">theory on MMU implementation of Riscv</a>.</p>
<p>As discussed in the theory :</p>
<ol>
<li>For us to use the MMU hardware, we need to activate it, choose a mode and finally switch our cpu from machine mode to either Supervisor mode or Usermode.</li>
<li>We need to map all the linker_initialized memory locations.</li>
<li>When mapping the heap, we need to set aside kernel heap and user_program heap.  Isolating the two is good for security... and modularity. It means the kernel will always have a dedicated heap and that it will not compete for space with the rest of the user programs.</li>
<li>We need to implement an access control mechanism.</li>
<li>Each process should get a dedicated virtual address space</li>
</ol>
<p>We will satisfy the above needs as follows :</p>
<h4 id="develop-a-virtual-mmu-instead-of-using-the-physical-mmu"><a class="header" href="#develop-a-virtual-mmu-instead-of-using-the-physical-mmu">Develop a Virtual MMU instead of using the physical MMU</a></h4>
<p>We will not use the MMU hardware. Meaning that our kernel will continue executing in machine mode. Our user programs will also execute in machine mode. Instead of using the MMU hardware, we will implement a virtual MMU that works in SV39 mode.
Using the MMU hardware could have given us many advantages :</p>
<ol>
<li>
<p>Performance: Physical MMUs provide faster and more efficient memory access than virtual MMUs. This is because physical MMUs are implemented in hardware, which makes them faster than software-based virtual MMUs. The physical MMU has caches that make memory translation process much faster.</p>
</li>
<li>
<p>Security: Physical MMUs provide better security than virtual MMUs. Physical MMUs can be used to implement hardware-based memory protection, which prevents unauthorized access to memory. This is not possible with virtual MMUs because they rely on software to implement memory protection.</p>
</li>
<li>
<p>Reliability: Physical MMUs are more reliable than virtual MMUs. Since physical MMUs are implemented in hardware, they are less prone to software bugs and errors, which can cause system crashes or data corruption.</p>
</li>
<li>
<p>Scalability: Physical MMUs are more scalable than virtual MMUs. As the size of physical memory increases, physical MMUs can be easily expanded to accommodate the increased memory, whereas virtual MMUs may require significant changes to the operating system and software.</p>
</li>
</ol>
<p>With all this advantages, it is obvious that using the hardware MMU is the right choice. So why use a virtual MMU?<br />
Learning and understanding how the hardware MMU works in detail takes time. It will be faster to just understand how the MMU works from a high level and implement it in software form. Most of the details involved around understanding the hardware MMU are centered around space optimization. As a result, there is much bitmasking and predefined procedures to follow.</p>
<p>For now, for the sake of implementation time, using the virtual MMU is the way to go.<br />
We will borrow SV39 mode concepts.</p>
<h4 id="major-tasks"><a class="header" href="#major-tasks">Major Tasks</a></h4>
<ol>
<li>Abstract the SATP register; This will help us identify : The process address space</li>
<li>Abstract the root table, parent table and child tables</li>
<li>Abstract the entries
<ul>
<li>branch and leaf entries</li>
</ul>
</li>
<li>Define functions to Map the Linker defined memory locations</li>
<li>Define functions to Map kernel heap addresses.</li>
<li>Define functions to Map user heap addresses</li>
<li>Define function to translate Linker defined memory locations</li>
<li>Define function to translate kernel heap addresses</li>
<li>Define function to translate user heap addresses</li>
<li>Define the API of the MMU
<ul>
<li>The exposed functions</li>
<li>The exposed structs</li>
<li>The success responses and error messages {this means you have to program }</li>
</ul>
</li>
</ol>
<h3 id="quick-detour"><a class="header" href="#quick-detour">Quick Detour....</a></h3>
<p>We will not implement the sv39 emulation due to time constraints. Such a disappointment. All that reading for nothing.  We will leave that for future Implementations.<br />
We will implement a one to one mapping. Something like this : </p>
<p><strong>The Translation Table.</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Process_with_access_rights</th><th>Access Parameter</th><th>Virtual memory</th><th>Physical Memory</th></tr></thead><tbody>
<tr><td>0(kernel)</td><td>R/E</td><td>0x80000000(text_section)</td><td>0x80000000</td></tr>
<tr><td>0(kernel)</td><td>R/W/E</td><td>0X80002000(stack_end)</td><td>0X80002000</td></tr>
<tr><td>0(kernel)</td><td>R/W/E</td><td>0x80005000 (Kernel_heap_start)</td><td>0x80005000</td></tr>
<tr><td>0(kernel)</td><td></td><td></td><td></td></tr>
<tr><td>1(init)</td><td></td><td></td><td></td></tr>
<tr><td>1(init)</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Our system is not fine_grained, meaning that to access a specific page, you have to first find the first allocated page for that associated with the contiguous block.<br />
Do not Let the transalation Table fool you, the Kernel process has first class access rights to all other processes. THis is dangerous, it will be fixed in the future [undone] </p>
<p>Kernel virtual addresses are mapped using a different mechanism from the one used to map user processes.<br />
Mapping is the process of populating an atomic entry in the the Translation table.</p>
<h4 id="the-mapping-procedure-for-processes-that-are-not-kernel-related"><a class="header" href="#the-mapping-procedure-for-processes-that-are-not-kernel-related">The Mapping procedure (For processes that are not Kernel related):</a></h4>
<ul>
<li>The OS decides to create space for a user process.</li>
<li>The OS realizes that it has to create space for each of the following process elements: 
<ul>
<li>The different LOAD-ABLE sections of the user process elf_file</li>
<li>The stack</li>
<li>The process structure </li>
</ul>
</li>
<li>It calls the allocator to help allocate pages for each of the above sections. The Elf sections should fall under a contiguous memory space. The allocator returns the physical start addresses for each element.</li>
<li>Now the kernel has the physical memories it can use to populate part of the Translation Table. The Translation table now looks as follows :</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Process_with_access_rights</th><th>Access Parameter</th><th>Virtual memory</th><th>Physical Memory</th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td>0xsome_address (text_section)</td></tr>
<tr><td></td><td></td><td></td><td>0xsome_address (data_section)</td></tr>
<tr><td></td><td></td><td></td><td>0xsome_address (bss_section)</td></tr>
<tr><td></td><td></td><td></td><td>0xsome_address (other_loadable_sections)</td></tr>
<tr><td></td><td></td><td></td><td>0xsome_address (Stack_start)</td></tr>
<tr><td></td><td></td><td></td><td>0xsome_address (Process Structure)</td></tr>
</tbody></table>
</div>
<ul>
<li>The kernel also has information about which processes have access to the allocated sections. ie 
<ul>
<li>The elf sections belong to the user process. Only the kernel and the user process have access to these sections</li>
<li>The stack belongs to the user process. Only the kernel and the user process have access to these sections.</li>
<li>The Process Struture belongs to the Kernel.</li>
</ul>
</li>
<li>So our Mapper function updates the table as follows :</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Process_with_access_rights</th><th>Access Parameter</th><th>Virtual memory</th><th>Physical Memory</th></tr></thead><tbody>
<tr><td>1(hello_world)</td><td></td><td></td><td>0xsome_address (text_section)</td></tr>
<tr><td>1(hello_world)</td><td></td><td></td><td>0xsome_address (data_section)</td></tr>
<tr><td>1(hello_world)</td><td></td><td></td><td>0xsome_address (bss_section)</td></tr>
<tr><td>1(hello_world)</td><td></td><td></td><td>0xsome_address (other_loadable_sections)</td></tr>
<tr><td>1(hello_world)</td><td></td><td></td><td>0xsome_address (Stack_start)</td></tr>
<tr><td>0(kernel)</td><td></td><td></td><td>0xsome_address (Process Structure)</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Now using an Elf reader, you extract info about the R/W/exeute access of each section of the elf file and update the relevant info in the Translation Table : 
| Process_with_access_rights | Access Parameter | Virtual memory | Physical Memory                          |
|----------------------------|------------------|----------------|------------------------------------------|
| 1(hello_world)             | R/E              |                | 0xsome_address (text_section)            |
| 1(hello_world)             | R/W              |                | 0xsome_address (data_section)            |
| 1(hello_world)             | R/W              |                | 0xsome_address (bss_section)             |
| 1(hello_world)             | applicable_right |                | 0xsome_address (other_loadable_sections) |
| 1(hello_world)             |                  |                | 0xsome_address (Stack_start)             |
| 0(kernel)                  |                  |                | 0xsome_address (Process Structure)       |</p>
</li>
<li>
<p>The stack is a read_write... is it? I really don't know.  The Process structure is also a read_write : </p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Process_with_access_rights</th><th>Access Parameter</th><th>Virtual memory</th><th>Physical Memory</th></tr></thead><tbody>
<tr><td>1(hello_world)</td><td>R/E</td><td></td><td>0xsome_address (text_section)</td></tr>
<tr><td>1(hello_world)</td><td>R/W</td><td></td><td>0xsome_address (data_section)</td></tr>
<tr><td>1(hello_world)</td><td>R/W</td><td></td><td>0xsome_address (bss_section)</td></tr>
<tr><td>1(hello_world)</td><td>applicable_right</td><td></td><td>0xsome_address (other_loadable_sections)</td></tr>
<tr><td>1(hello_world)</td><td>R/W</td><td></td><td>0xsome_address (Stack_start)</td></tr>
<tr><td>0(kernel)</td><td>R/W</td><td></td><td>0xsome_address (Process Structure)</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>now we are left with the virtual memory coulumn. Each Virtual memory address belonging to a particular process needs to be unique when compared to other virtual addresses assigned to the same process. However, virtual memory addresses belonging to different processes can be similar because they are under different processes.</p>
</li>
<li>
<p>The Virtual addresses for the different elf sections can be extracted from the elf file using the elf_reader. So the Translation Table becomes :<br />
| Process_with_access_rights | Access Parameter | Virtual memory              | Physical Memory                          |
|----------------------------|------------------|-----------------------------|------------------------------------------|
| 1(hello_world)             | R/E              | elf text_section            | 0xsome_address (text_section)            |
| 1(hello_world)             | R/W              | elf data_section            | 0xsome_address (data_section)            |
| 1(hello_world)             | R/W              | elf bss_section             | 0xsome_address (bss_section)             |
| 1(hello_world)             | applicable_right | elf other_loadable_sections | 0xsome_address (other_loadable_sections) |
| 1(hello_world)             | R/W              |                             | 0xsome_address (Stack_start)             |
| 0(kernel)                  | R/W              |                             | 0xsome_address (Process Structure)       |</p>
</li>
<li>
<p>If the elf file specifies the virtual address of the stack... use it.</p>
</li>
<li>
<p>If the elf file does not specify the virtual address for the Stack, you assign it a virtual address that does not coincide with any of the elf virtual addresses. To make sure of this, you pick a virtual address that comes right after the end of the virtual addresses specified in the elf file. The chosen address needs to be aligned to a multiple of 4096.</p>
</li>
</ul>
<p>So the Translation Table now is updated to this :<br />
| Process_with_access_rights | Access Parameter | Virtual memory                  | Physical Memory                          |
|----------------------------|------------------|---------------------------------|------------------------------------------|
| 1(hello_world)             | R/E              | elf text_section                | 0xsome_address (text_section)            |
| 1(hello_world)             | R/W              | elf data_section                | 0xsome_address (data_section)            |
| 1(hello_world)             | R/W              | elf bss_section                 | 0xsome_address (bss_section)             |
| 1(hello_world)             | applicable_right | elf other_loadable_sections     | 0xsome_address (other_loadable_sections) |
| 1(hello_world)             | R/W              | (elf stack) OR (after_elf addr) | 0xsome_address (Stack_start)             |
| 0(kernel)                  | R/W              | 0xsome_address_X                | 0xsome_address_X (Process Structure)     |</p>
<ul>
<li>Now what remains is the Kernel virtual address. Drum rolls.... Boom! : The Kernel does not use virtual addresses that are different from the physical addresses. Kernel virtual addresses are straight foward : a one-to-one mapping. This decision is NOT a bad decision. This is because you can treat the Kernel virtual addresses as normal virtual addresses. for example, multiple virtual addresses can point to a single physical address.</li>
</ul>
<h4 id="the-translation-process"><a class="header" href="#the-translation-process">The Translation Process</a></h4>
<p>When a process wants to access the RAM, it uses virtual addresses.  The instructions inside the elf binary reference virtual memory addresses. The Data inside the elf binary file also reference virtual addresses. So when the CPU executes a user_program instruction, it needs to first translate </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="fine_grained_alloation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="handling_the_Physical_MMU.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="fine_grained_alloation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="handling_the_Physical_MMU.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </body>
</html>
